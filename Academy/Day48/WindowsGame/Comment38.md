## Direct X

수업을 진행할 내용은
Direct X 버전이 여러개있는데

Direct 9 ~ Direct 12 까지 다양하게 있다.

Direct 11을 가장 많이 쓴다.

[Direct 12부터는 너무 전문가용이 되어버렸다.]
=> 하드웨어에 너무 많은 관여를 하게된다.
=> 사실 프로그래머 입장에서는 대충 알잘딱 해주기를 원하는데
=> 지금부터 하드웨어 가속화해라. 지금은 가만히있어라.
=> 이런것들은 다 명령을 내려주는 파이프라인을 일일히 짜줘야한다.
그래서 요즘 나온 Unity, Unreal 버전들 이 엔진들은 Dirtect 12를 써서 많은 최적화를 이루어냈다.

### Direct X란?

Windows API는 Graphis 로 표현시키기위한 어플리케이션 프로그래밍

배우 Windows API 는 대부분 그림그리는데 사용했다.

Direct X는 하드웨어를 100% 활용하기 위해서 나온 Microsoft의 라이브러리이다.

그동안 배운 내용중에서 하드웨어를 쓴 내용이 없다.

[하드웨어를 컨트롤할수있는 API]

이중에서 가장 보편적으로 알려진 사실

3D를 그릴수있게 해준다.

말이 3D지 어떻게든하면 2D 이긴 하다.


### 그래서 배울 Direct X는?

Direct 11을 배울거다.
그런데 그중에서도 Direct2D 11을 배울거다.

> Direct 12같은 경우에는 너무 전문가용이기 때문에 이론용으로 적합하지 않는다.
> Direct 11같은 경우에는 배울시간이 넉넉치 않다.
 - 기본적으로 렌더링파이프라인에 대해 A to Z를 직접 해보는게 Direct X의 수업과정이다. 보통
> 포폴에 png 쓰기위해서.
> 그리고 간접적으로 DirectX에 대해 체험하고 어떤원리인지 파악하려고

> 좀 쉬운 Direct2D를 배운다.

> 다른 학원들 DirectX를 가르칠때 Direct 11의 렌더링 파이프라인을 직접 구현해보는 과정을
  3개월 투자한다.

==> 결과가, 아무도 Direct X에대해 모른다.

> 게임학과에서는 1년을 배운다.
==> 결과가, 교수도 틀린다.

Direct X를 배우는 이유.
 - 3D 클라이언트 개발자라면, 렌더링 파이프라인을 알아야 한다.
  -> 그래서 원리를 배우는 과정이다.
 - 하드웨어 가속에 대해 해봐야 한다.
 - 그냥 교양느낌.
 - 엔진 프로그래머로 갈거라면 필수이다.
	
### **렌더링 파이프라인** (Cheat Seat)

렌더링 파이프라인이 대체 무엇이냐??

화면에 무언가를 그리기위해서 무슨행동을 하냐이다.

Windows API도 렌더링 파이프라인이 엄연히 따지면 있다.
그런데 1줄짜리라 그렇다.
 > Blt 라는 함수로 비트맵끼리 고속복사를 한다.
 > CPU를 활용하는거다보니, 많이 느리다.

GPU(그래픽카드)가 CPU보다 훨씬 빠르다.
그래서 GPU와 CPU를 적절히 활용해서 화면에 그림을 그린다.

1. Vertex Shader
2. Tessellation
3. Geometry Shader
4. Rasterization
5. Pixel Shader (Fragment Shader)
6. Frame Buffer

연산 수행은 CPU밖에 못한다.
GPU는 그냥 진짜 빠른애이다.
그게 끝이다.

> GPU를 활용하기 위해서는 어떻게 해야할까?
> GPU만의 문법을 적어줘야한다.
>> Shader라는 코드 (HLSL이라는 문법) (놀랍게도 아티스트가 다루는 문법이다.)
>> 요즘은 비주얼 쉐이더라고 그래프 띡 연결하면 HLSL문법이 짜주는 툴들이 많이 나왔다.

[3D 게임 예시]
집 모델링 데이터 (Max나 블렌더같은 3D툴로 만들어진 3D 모델링이다.)
얘네를 대체 어떻게 화면에 뿌릴수 있을까?

정육면체로 생각해보자.
(1,1,1)   (1,1,-1)
(1,-1,1)  (1,-1,-1)
(-1,-1,1) (-1,-1,-1)
(-1,1,1)  (-1,1,-1)

점이 8개가 표현돼서 저렇게 보이는 이유는
3가지 조건이 만족하기 때문
(1. 월드 위치) (World)
 - 해당 도형의 꼭지점 (정점, Vertex) 위치
 - 해당 도형의 꼭지점 (정점, Vertex) 의 회전값

(2. 카메라 위치) (View)
 - 저 도형을 관찰하는 카메라 위치.
 - 저 도형을 관찰하는 카메라의 회전값

(3. 카메라 원근값) (Projection)
 - 2D 카메라인지. 3D 카메라인지
 - 3D 카메라라면 시야각이 몇도인지.
	

- Vertex Data를 Shader에 넘겨준다.
- World, View, Projection이라는 과정을 거친다.
이 과정을 거칠때 (4x4 행렬 곱을 사용하여 연산을 한다.)

World 행렬
View 행렬
Projection 행렬
이 존재한다.

World - 게임세상에 존재하는 모든 모델들의 정점 데이터를 행렬로 만들어준다.

(position.x, position.y, poition.z , 1)
(rotation.x, rotation.y, rotation.y, 1)
(scale.x scale.y, scale.z, 1)
(1, 1, 1, 1)

View - World에 존재하는 모든 정점행렬들을 내 현재 카메라에 맞게 수정해준다.
(World행렬에 View행렬을 곱해준다.)

Projection - World * view에 Projection을 곱해준다.
 => 실제로 스크린화면에서 어디에 그려줘야하는지 맞춰서 재조정을 해준다.
 => 최적화를 해준다. (안그려도 될 모델같은 경우에는 여기에서 컷을 해준다.)
    (frustom culling)

### 2. Tessellation (최적화 작업)

하는게임도 있고 안하는 게임도 있다.

스크린화면은 보통 FHD (1920 *1080) 화면으로 플레이한다.

(2000 * 1000) => 2000000 2백만 픽셀

폴리곤수에 비해 픽셀이 부족할때가 많다.
정점수가 너무많다.

- Level Of Detail (LOD)
 > 카메라로부터 멀리 있는 오브젝트일수록, 로우 폴리곤 모델을 사용하도록 변경해주는 작업
   (모델러가 작업)

### 3. Geometry Shader (퀄리티 작업) (최적화 반대)

- 그림자를 만드는 작업
(엄청 무거운 작업)

- 먼저 그림을 그리고
- 그 그림위에 한번더 빛기준으로 누워진 방향으로 검은그림자를 한번더 그린다.
  그렇기 때문에 한번만 그리면 될거를 두번그리는거다.
  (그림자 on == 부하 2배)

### 4. Rasterization (픽셀대입) (GPU)

- 각 Pixel당, 어떤색으로 칠하면 될지, 색 보간작업을 진행한다.
- Texture 입히기

### 5. Pixel Shader (Fragment Shader)

화면 픽셀수 만큼 계산해준다.
1920 * 1080 => 2백만번 계산해준다.
4K 3840 * 2160 => 8백만번 계산해준다.

- 조명효과, 오브젝트끼리의 조명 방해 등을 계산해준다.

### 6. Frame Buffer (DirectX 내용이 아니다.) (엔진을 할때도 직접 컨트롤해야하는 부분이다.)

엔진을 할때도 가장 최상급 퀄리티 작업으로 분류된다.

- Alpha Blending
 > Alpha (투명색) 끼리 만났을때 다른색으로 나오게하는 작업.

- Stencil Buffer (최종기믹 효과)
 > 방탈출 게임에서
 > [책상안쪽 확인하기] 책상위에 돋보기를 가져다대면, 책상서랍이 보인다.
   (책상모델링은 가만히 있는데, 책상안쪽을 보여준다.)

- Z-Test
- Z-Fighting
 둘다 3D 모델이고 같은 영역에 걸쳐있을때, 어떤 모델로 보여주게할지
 [GPU가 처리하기때문에, 어떻게될지 모른다.]
 [GPU는 병렬로 일을하기 때문에, 뭐가 먼저 오는지 모른다.]

 Windows API 같은경우에는 그냥 먼저그린걸 보여줬다.

 - SkyBox